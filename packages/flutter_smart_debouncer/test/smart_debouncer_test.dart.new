import 'dart:async';

import 'package:fake_async/fake_async.dart';
import 'package:flutter_smart_debouncer/flutter_smart_debouncer.dart';
import 'package:test/test.dart';

void main() {
  group('SmartDebouncer', () {
    test('leading only executes immediately', () {
      FakeAsync().run((async) {
        final debouncer = SmartDebouncer<int>(
          delay: const Duration(milliseconds: 100),
          leading: true,
          trailing: false,
        );

        var count = 0;
        debouncer(() => ++count);
        expect(count, 1);
        
        // Subsequent calls within delay should be ignored
        async.elapse(const Duration(milliseconds: 50));
        debouncer(() => ++count);
        expect(count, 1);
        
        // After delay, next call should execute immediately
        async.elapse(const Duration(milliseconds: 60));
        debouncer(() => ++count);
        expect(count, 2);
      });
    });

    test('trailing only executes after delay', () {
      FakeAsync().run((async) {
        final debouncer = SmartDebouncer<int>(
          delay: const Duration(milliseconds: 100),
          leading: false,
          trailing: true,
        );

        var count = 0;
        debouncer(() => ++count);
        expect(count, 0);
        
        // Should not execute until delay has passed
        async.elapse(const Duration(milliseconds: 50));
        expect(count, 0);
        
        // After delay, should execute once
        async.elapse(const Duration(milliseconds: 60));
        expect(count, 1);
      });
    });

    test('leading and trailing executes first and last', () {
      FakeAsync().run((async) {
        final debouncer = SmartDebouncer<int>(
          delay: const Duration(milliseconds: 100),
          leading: true,
          trailing: true,
        );

        var count = 0;
        // First call executes immediately (leading)
        debouncer(() => ++count);
        expect(count, 1);
        
        // Subsequent call within delay is queued
        async.elapse(const Duration(milliseconds: 50));
        debouncer(() => ++count);
        expect(count, 1);
        
        // After delay, trailing executes
        async.elapse(const Duration(milliseconds: 60));
        expect(count, 2);
      });
    });

    test('maxWait forces execution', () {
      FakeAsync().run((async) {
        final debouncer = SmartDebouncer<int>(
          delay: const Duration(milliseconds: 100),
          maxWait: const Duration(milliseconds: 200),
          leading: false,
          trailing: true,
        );

        var count = 0;
        // Initial call
        debouncer(() => ++count);
        expect(count, 0);
        
        // Multiple rapid calls within maxWait
        for (var i = 0; i < 5; i++) {
          async.elapse(const Duration(milliseconds: 30));
          debouncer(() => ++count);
        }
        
        // Should not have executed yet (delay not reached)
        expect(count, 0);
        
        // After maxWait, should execute
        async.elapse(const Duration(milliseconds: 60));
        expect(count, 1);
      });
    });

    test('cancel prevents execution', () {
      FakeAsync().run((async) {
        final debouncer = SmartDebouncer<int>(
          delay: const Duration(milliseconds: 100),
          leading: false,
          trailing: true,
        );

        var count = 0;
        debouncer(() => ++count);
        debouncer.cancel();
        
        async.elapse(const Duration(milliseconds: 150));
        expect(count, 0);
      });
    });

    test('flush executes pending action immediately', () {
      FakeAsync().run((async) async {
        final debouncer = SmartDebouncer<int>(
          delay: const Duration(milliseconds: 100),
          leading: false,
          trailing: true,
        );

        var count = 0;
        debouncer(() => ++count);
        
        // Flush before delay
        await debouncer.flush();
        expect(count, 1);
        
        // Should not execute again after delay
        async.elapse(const Duration(milliseconds: 150));
        expect(count, 1);
      });
    });

    test('pause and resume timers', () {
      FakeAsync().run((async) {
        final debouncer = SmartDebouncer<int>(
          delay: const Duration(milliseconds: 100),
          leading: false,
          trailing: true,
        );

        var count = 0;
        debouncer(() => ++count);
        
        // Pause before delay completes
        async.elapse(const Duration(milliseconds: 50));
        debouncer.pause();
        
        // Time passing while paused should not trigger execution
        async.elapse(const Duration(milliseconds: 60));
        expect(count, 0);
        
        // Resume and complete remaining delay
        debouncer.resume();
        async.elapse(const Duration(milliseconds: 60));
        expect(count, 1);
      });
    });

    test('dispose prevents further calls', () {
      final debouncer = SmartDebouncer<int>(
        delay: const Duration(milliseconds: 100),
        leading: true,
        trailing: true,
      );

      var count = 0;
      debouncer.dispose();
      
      expect(
        () => debouncer(() => ++count),
        throwsA(isA<StateError>()),
      );
    });

    test('async action completion', () async {
      final debouncer = SmartDebouncer<int>(
        delay: const Duration(milliseconds: 100),
        leading: true,
        trailing: false,
      );

      var count = 0;
      final completer = Completer<void>();
      
      // Start an async action
      final future = debouncer(() async {
        count++;
        await completer.future;
        return count;
      });
      
      expect(count, 1);
      
      // Subsequent calls should be ignored while first is still running
      debouncer(() => ++count);
      expect(count, 1);
      
      // Complete the async action
      completer.complete();
      final result = await future;
      
      expect(result, 1);
      
      // Next call should execute
      await debouncer(() => ++count);
      expect(count, 2);
    });
  });
}
